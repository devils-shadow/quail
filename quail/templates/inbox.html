{% extends "layout.html" %}
{% set body_class = "list-view inbox-view" %}
{% block content %}
<div class="list-page">
  <div class="page-header">
    <div>
      <h1 class="page-title">Received Mail</h1>
      <p class="page-subtitle">Ephemeral mail for testing and development.</p>
    </div>
    <div class="toolbar">
      <button class="theme-toggle" id="theme-toggle" type="button" aria-label="Toggle theme">
        <span class="theme-toggle__icon theme-toggle__icon--sun">‚òÄÔ∏è</span>
        <span class="theme-toggle__thumb" aria-hidden="true"></span>
        <span class="theme-toggle__icon theme-toggle__icon--moon">üåö</span>
      </button>
      <form method="get" action="/inbox">
        <input
          class="input round input--filter"
          type="text"
          name="inbox"
          value="{{ current_inbox | default('') }}"
          placeholder="Filter inbox (e.g. test123, test*)"
        />
        <button class="button square round" type="submit">
          <span class="button-label">GO</span>
        </button>
      </form>
      <button class="button secondary icon round" id="trash-button" type="button" aria-label="Delete messages">
        üóëÔ∏è
      </button>
      <button class="button secondary icon round" id="pause-button" type="button" aria-label="Pause refresh">
        ‚è∏Ô∏è
      </button>
    </div>
  </div>

  <div class="list-body">
    <div class="list-scroll">
      <div class="card list-scroll-card list-scroll-card--inbox">
        <div class="list-scroll-head">
          <table class="table inbox-table inbox-table--head">
            <thead>
              <tr>
                <th class="from-col">From</th>
                <th class="to-col">To</th>
                <th class="subject-col">Subject</th>
                <th class="received-col">Received</th>
              </tr>
            </thead>
          </table>
        </div>
        <div class="list-scroll-body">
          <table class="table inbox-table inbox-table--body">
            <tbody>
              {% if messages %}
              {% set inbox_query = "" %}
              {% if current_inbox %}
              {% set inbox_query = "?inbox=" ~ (current_inbox | urlencode) %}
              {% endif %}
              {% for message in messages %}
              {% set from_display = message.from_addr or "Unknown" %}
              {% if "<" in from_display %}
              {% set from_display = from_display.split("<")[0].strip().strip('"') %}
              {% elif "@" in from_display %}
              {% set from_display = from_display.split("@")[0] %}
              {% endif %}
              {% set to_display = message.envelope_rcpt or "" %}
              {% if "@" in to_display %}
              {% set to_display = to_display.split("@")[0] %}
              {% endif %}
              <tr data-message-id="{{ message.id }}" data-href="/message/{{ message.id }}{{ inbox_query }}">
                <td class="from-col">
                  <input class="message-select" type="checkbox" aria-label="Select message" />
                  <span class="from-text">{{ from_display }}</span>
                  {% if is_admin and message.quarantined %}
                  <span class="badge">Quarantined</span>
                  {% endif %}
                </td>
                <td class="to-col">{{ to_display }}</td>
                <td class="subject-col">
                  <a href="/message/{{ message.id }}{{ inbox_query }}">
                    {{ message.subject or "(No subject)" }}
                  </a>
                </td>
                <td class="received-col received-cell" data-received-at="{{ message.received_at }}">
                  {{ message.received_at }}
                </td>
              </tr>
              {% endfor %}
              <tr data-empty-state style="display: none;">
                <td colspan="3">
                  <div class="empty-state">
                    {% if current_inbox %}
                    <div><strong>Currently filtered inbox has no mail.</strong></div>
                    <div class="row-muted" aria-hidden="true">&nbsp;</div>
                    {% else %}
                    <div><strong>This is an ephemeral inbox.</strong></div>
                    <div class="row-muted">Messages are only shown after you apply a filter.</div>
                    {% endif %}
                  </div>
                </td>
              </tr>
              {% else %}
              <tr data-empty-state>
                <td colspan="3">
                  <div class="empty-state">
                    {% if current_inbox %}
                    <div><strong>Currently filtered inbox has no mail.</strong></div>
                    <div class="row-muted" aria-hidden="true">&nbsp;</div>
                    {% else %}
                    <div><strong>This is an ephemeral inbox.</strong></div>
                    <div class="row-muted">Messages are only shown after you apply a filter.</div>
                    {% endif %}
                  </div>
                </td>
              </tr>
              {% endif %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
  const hiddenKey = "quailHiddenMessages";
  const themeStorageKey = "quailTheme";
  const pauseKey = "quailInboxPaused";
  const wsEnabled = {{ "true" if enable_ws else "false" }};
  const pollingIntervalMs = wsEnabled ? 15000 : 3000;
  const hasFilter = {{ "true" if current_inbox else "false" }};
  const inboxQuery =
    "{% if current_inbox %}?inbox={{ current_inbox | urlencode }}{% endif %}";
  const inboxApiUrl = `/api/inbox${inboxQuery}`;
  const wsProtocol = window.location.protocol === "https:" ? "wss" : "ws";
  const wsUrl = `${wsProtocol}://${window.location.host}/ws/inbox${inboxQuery}`;
  const isAdmin = {{ "true" if is_admin else "false" }};
  const tableBody = document.querySelector(".inbox-table--body tbody");
  let rows = Array.from(document.querySelectorAll("tr[data-message-id]"));
  let emptyRow = document.querySelector("[data-empty-state]");
  const trashButton = document.getElementById("trash-button");
  const pauseButton = document.getElementById("pause-button");
  let messageCache = new Map();
  let refreshTimer = null;
  let refreshInFlight = false;
  let lastEtag = null;
  let ws = null;
  let wsRetryMs = 1000;
  let wsRetryTimer = null;

  const resetRows = () => {
    rows = Array.from(document.querySelectorAll("tr[data-message-id]"));
    emptyRow = document.querySelector("[data-empty-state]");
  };

  const readHidden = () => {
    try {
      const raw = window.sessionStorage.getItem(hiddenKey);
      const parsed = raw ? JSON.parse(raw) : [];
      return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
      return [];
    }
  };

  const writeHidden = (items) => {
    try {
      window.sessionStorage.setItem(hiddenKey, JSON.stringify(items));
    } catch (error) {
      // Ignore storage errors.
    }
  };

  const updateEmptyState = () => {
    if (!emptyRow) {
      return;
    }
    const visibleRows = rows.filter((row) => !row.classList.contains("row-hidden"));
    emptyRow.style.display = visibleRows.length ? "none" : "table-row";
  };

  const applyHidden = () => {
    const hidden = new Set(readHidden());
    rows.forEach((row) => {
      const id = row.dataset.messageId;
      if (hidden.has(id)) {
        row.classList.add("row-hidden");
      }
    });
    updateEmptyState();
  };

  const buildEmptyRow = () => {
    const row = document.createElement("tr");
    row.dataset.emptyState = "true";
    const cell = document.createElement("td");
    cell.colSpan = 4;
    const emptyState = document.createElement("div");
    emptyState.className = "empty-state";
    const title = document.createElement("div");
    const titleStrong = document.createElement("strong");
    titleStrong.textContent = hasFilter
      ? "Currently filtered inbox has no mail."
      : "This is an ephemeral inbox.";
    title.appendChild(titleStrong);
    emptyState.appendChild(title);
    const detail = document.createElement("div");
    detail.className = "row-muted";
    if (hasFilter) {
      detail.setAttribute("aria-hidden", "true");
      detail.textContent = "\u00a0";
    } else {
      detail.textContent = "Messages are only shown after you apply a filter.";
    }
    emptyState.appendChild(detail);
    cell.appendChild(emptyState);
    row.appendChild(cell);
    return row;
  };

  const buildMessageRow = (message) => {
    const row = document.createElement("tr");
    row.dataset.messageId = message.id;
    row.dataset.href = `/message/${message.id}${inboxQuery}`;

    const formatFrom = (rawValue) => {
      if (!rawValue) {
        return "Unknown";
      }
      const trimmed = String(rawValue).trim();
      if (!trimmed) {
        return "Unknown";
      }
      if (trimmed.includes("<")) {
        return trimmed.split("<")[0].replace(/"/g, "").trim() || "Unknown";
      }
      if (trimmed.includes("@")) {
        const localPart = trimmed.split("@")[0].trim();
        return localPart || "Unknown";
      }
      return trimmed;
    };

    const fromCell = document.createElement("td");
    fromCell.className = "from-col";
    const checkbox = document.createElement("input");
    checkbox.className = "message-select";
    checkbox.type = "checkbox";
    checkbox.setAttribute("aria-label", "Select message");
    fromCell.appendChild(checkbox);
    const fromText = document.createElement("span");
    fromText.className = "from-text";
    fromText.textContent = ` ${formatFrom(message.from_addr)}`;
    fromCell.appendChild(fromText);
    if (isAdmin && message.quarantined) {
      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = "Quarantined";
      fromCell.appendChild(badge);
    }

    const toCell = document.createElement("td");
    toCell.className = "to-col";
    const toValue = message.envelope_rcpt || "";
    const toDisplay = toValue.includes("@") ? toValue.split("@")[0] : toValue;
    toCell.textContent = toDisplay;

    const subjectCell = document.createElement("td");
    subjectCell.className = "subject-col";
    const link = document.createElement("a");
    link.href = `/message/${message.id}${inboxQuery}`;
    link.textContent = message.subject || "(No subject)";
    subjectCell.appendChild(link);

    const receivedCell = document.createElement("td");
    receivedCell.className = "received-col received-cell";
    receivedCell.className = "received-cell";
    receivedCell.dataset.receivedAt = message.received_at || "";
    receivedCell.textContent = formatReceivedAt(message.received_at || "");
    const parsedReceived = message.received_at
      ? parseReceivedDate(message.received_at)
      : null;
    if (parsedReceived) {
      receivedCell.title = formatAbsoluteTimestamp(parsedReceived);
    }

    row.appendChild(fromCell);
    row.appendChild(toCell);
    row.appendChild(subjectCell);
    row.appendChild(receivedCell);
    return row;
  };

  const renderMessagesFromCache = () => {
    const messages = Array.from(messageCache.values());
    messages.sort((a, b) => {
      const aTime = new Date(a.received_at || 0).getTime();
      const bTime = new Date(b.received_at || 0).getTime();
      return bTime - aTime;
    });
    renderMessages(messages);
  };

  const setCache = (messages) => {
    messageCache = new Map();
    messages.forEach((message) => {
      messageCache.set(String(message.id), message);
    });
    renderMessagesFromCache();
  };

  const applyDelta = (payload) => {
    let changed = false;
    if (Array.isArray(payload.added)) {
      payload.added.forEach((message) => {
        messageCache.set(String(message.id), message);
        changed = true;
      });
    }
    if (Array.isArray(payload.updated)) {
      payload.updated.forEach((message) => {
        messageCache.set(String(message.id), message);
        changed = true;
      });
    }
    if (Array.isArray(payload.deleted)) {
      payload.deleted.forEach((id) => {
        if (messageCache.delete(String(id))) {
          changed = true;
        }
      });
    }
    if (changed) {
      renderMessagesFromCache();
    }
  };

  const renderMessages = (messages) => {
    if (!tableBody) {
      return;
    }
    const fragment = document.createDocumentFragment();
    messages.forEach((message) => {
      fragment.appendChild(buildMessageRow(message));
    });
    const emptyStateRow = buildEmptyRow();
    emptyStateRow.style.display = messages.length ? "none" : "table-row";
    fragment.appendChild(emptyStateRow);
    tableBody.replaceChildren(fragment);
    resetRows();
    applyHidden();
    applyReceivedFormatting();
  };

  const pad2 = (value) => String(value).padStart(2, "0");

  const formatAbsoluteTimestamp = (date) =>
    `${pad2(date.getHours())}:${pad2(date.getMinutes())}:${pad2(
      date.getSeconds()
    )} ${pad2(date.getDate())}/${pad2(date.getMonth() + 1)}/${date.getFullYear()}`;

  const parseReceivedDate = (rawValue) => {
    const parsed = new Date(rawValue);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  };

  const formatReceivedAt = (rawValue) => {
    if (!rawValue) {
      return "";
    }
    const parsed = parseReceivedDate(rawValue);
    if (!parsed) {
      return rawValue;
    }
    const now = new Date();
    let diffMs = now.getTime() - parsed.getTime();
    const clockSkewMs = 60000;
    if (diffMs < -clockSkewMs) {
      return formatAbsoluteTimestamp(parsed);
    }
    if (diffMs < 0) {
      diffMs = 0;
    }
    const seconds = Math.floor(diffMs / 1000);
    if (seconds < 45) {
      return "just now";
    }
    if (seconds < 90) {
      return "1 minute ago";
    }
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) {
      return `${minutes} minutes ago`;
    }
    const hours = Math.floor(minutes / 60);
    if (hours < 24) {
      return `${hours} ${hours === 1 ? "hour" : "hours"} ago`;
    }
    const days = Math.floor(hours / 24);
    if (days < 7) {
      return `${days} ${days === 1 ? "day" : "days"} ago`;
    }
    return formatAbsoluteTimestamp(parsed);
  };

  const applyReceivedFormatting = () => {
    const cells = document.querySelectorAll(".received-cell[data-received-at]");
    cells.forEach((cell) => {
      const rawValue = cell.dataset.receivedAt;
      const formatted = formatReceivedAt(rawValue);
      cell.textContent = formatted;
      const parsed = rawValue ? parseReceivedDate(rawValue) : null;
      if (parsed) {
        cell.title = formatAbsoluteTimestamp(parsed);
      }
    });
  };

  const startReceivedTicker = () => {
    window.setInterval(applyReceivedFormatting, 60000);
  };

  const hasSameMessages = (messages) => {
    if (rows.length !== messages.length) {
      return false;
    }
    return rows.every((row, index) => row.dataset.messageId == messages[index].id);
  };

  const isPaused = () => window.sessionStorage.getItem(pauseKey) === "true";

  const setTheme = (theme) => {
    document.documentElement.dataset.theme = theme;
    document.documentElement.style.colorScheme = theme;
    try {
      window.localStorage.setItem(themeStorageKey, theme);
    } catch (error) {
      // Ignore storage errors.
    }
  };

  const getTheme = () => {
    const stored = window.localStorage.getItem(themeStorageKey);
    return stored || document.documentElement.dataset.theme || "light";
  };

  const updateThemeToggle = () => {
    const toggle = document.getElementById("theme-toggle");
    if (!toggle) {
      return;
    }
    const theme = getTheme();
    const isDark = theme === "dark";
    toggle.setAttribute("aria-pressed", isDark ? "true" : "false");
    toggle.setAttribute("title", isDark ? "Switch to light mode" : "Switch to dark mode");
  };

  const refreshInbox = async () => {
    if (refreshInFlight || document.hidden) {
      return;
    }
    if (isPaused()) {
      return;
    }
    refreshInFlight = true;
    try {
      const headers = {};
      if (lastEtag) {
        headers["If-None-Match"] = lastEtag;
      }
      const response = await fetch(inboxApiUrl, { cache: "no-store", headers });
      if (response.status === 304) {
        return;
      }
      if (!response.ok) {
        return;
      }
      const nextEtag = response.headers.get("ETag");
      if (nextEtag) {
        lastEtag = nextEtag;
      }
      const payload = await response.json();
      if (isPaused()) {
        return;
      }
      if (!payload || !Array.isArray(payload.messages)) {
        return;
      }
      if (!hasSameMessages(payload.messages)) {
        setCache(payload.messages);
      }
    } catch (error) {
      // Ignore refresh errors.
    } finally {
      refreshInFlight = false;
    }
  };

  const startPolling = () => {
    if (refreshTimer || pollingIntervalMs <= 0) {
      return;
    }
    refreshTimer = window.setInterval(refreshInbox, pollingIntervalMs);
  };

  const stopPolling = () => {
    if (!refreshTimer) {
      return;
    }
    window.clearInterval(refreshTimer);
    refreshTimer = null;
  };

  const scheduleWsRetry = () => {
    if (!wsEnabled || wsRetryTimer) {
      return;
    }
    wsRetryTimer = window.setTimeout(() => {
      wsRetryTimer = null;
      startWebSocket();
    }, wsRetryMs);
    wsRetryMs = Math.min(wsRetryMs * 2, 10000);
  };

  const resetWsRetry = () => {
    wsRetryMs = 1000;
    if (wsRetryTimer) {
      window.clearTimeout(wsRetryTimer);
      wsRetryTimer = null;
    }
  };

  const forceSnapshotRefresh = async () => {
    try {
      const response = await fetch(inboxApiUrl, { cache: "no-store" });
      if (!response.ok) {
        return;
      }
      const payload = await response.json();
      if (payload && Array.isArray(payload.messages)) {
        setCache(payload.messages);
      }
    } catch (error) {
      // Ignore refresh errors.
    }
  };

  const handleWsMessage = (event) => {
    if (isPaused()) {
      return;
    }
    let payload = null;
    try {
      payload = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    if (!payload || typeof payload.type !== "string") {
      return;
    }
    if (payload.type === "snapshot") {
      if (Array.isArray(payload.messages)) {
        setCache(payload.messages);
      }
      if (payload.etag) {
        lastEtag = payload.etag;
      }
      return;
    }
    if (payload.type === "delta") {
      const removed = Array.isArray(payload.deleted) ? payload.deleted : [];
      const updated = Array.isArray(payload.updated) ? payload.updated : [];
      const deletedMissing = removed.some((id) => !messageCache.has(String(id)));
      const updatedMissing = updated.some(
        (message) => !messageCache.has(String(message.id))
      );
      if (deletedMissing || updatedMissing) {
        if (ws) {
          ws.close();
        }
        forceSnapshotRefresh();
        return;
      }
      applyDelta(payload);
      if (payload.etag) {
        lastEtag = payload.etag;
      }
      return;
    }
  };

  const startWebSocket = () => {
    if (!wsEnabled || ws) {
      return;
    }
    ws = new WebSocket(wsUrl);
    ws.addEventListener("open", () => {
      stopPolling();
      resetWsRetry();
    });
    ws.addEventListener("message", handleWsMessage);
    ws.addEventListener("close", () => {
      ws = null;
      startPolling();
      scheduleWsRetry();
    });
    ws.addEventListener("error", () => {
      if (ws) {
        ws.close();
      }
    });
  };

  const updatePauseButton = () => {
    if (!pauseButton) {
      return;
    }
    const paused = isPaused();
    pauseButton.classList.toggle("paused", paused);
    pauseButton.textContent = paused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
    pauseButton.setAttribute(
      "aria-label",
      paused ? "Resume refresh" : "Pause refresh"
    );
    pauseButton.setAttribute(
      "title",
      paused ? "Resume refresh (this session only)" : "Pause refresh (this session only)"
    );
  };

  if (trashButton) {
    trashButton.addEventListener("click", () => {
      const selected = rows.filter((row) =>
        row.querySelector(".message-select")?.checked
      );
      if (!selected.length) {
        return;
      }
      const hidden = new Set(readHidden());
      selected.forEach((row) => {
        const id = row.dataset.messageId;
        if (id) {
          hidden.add(id);
          row.classList.add("row-hidden");
        }
        const checkbox = row.querySelector(".message-select");
        if (checkbox) {
          checkbox.checked = false;
        }
      });
      writeHidden(Array.from(hidden));
      updateEmptyState();
    });
  }

  if (tableBody) {
    tableBody.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof Element)) {
        return;
      }
      if (target.closest("a, button, input, label, select, textarea")) {
        return;
      }
      const row = target.closest("tr[data-href]");
      if (!row) {
        return;
      }
      const href = row.dataset.href;
      if (href) {
        window.location.href = href;
      }
    });
  }

  const themeToggle = document.getElementById("theme-toggle");
  if (themeToggle) {
    themeToggle.addEventListener("click", () => {
      const nextTheme = getTheme() === "dark" ? "light" : "dark";
      setTheme(nextTheme);
      updateThemeToggle();
    });
    updateThemeToggle();
  }

  if (pauseButton) {
    pauseButton.addEventListener("click", () => {
      const paused = isPaused();
      window.sessionStorage.setItem(pauseKey, String(!paused));
      updatePauseButton();
    });
    updatePauseButton();
  }

  const handleVisibilityChange = () => {
    if (!wsEnabled) {
      return;
    }
    if (document.hidden) {
      return;
    }
    if (!ws) {
      startWebSocket();
    }
  };

  if (wsEnabled) {
    startWebSocket();
    document.addEventListener("visibilitychange", handleVisibilityChange);
  } else {
    startPolling();
  }

  applyHidden();
  applyReceivedFormatting();
  startReceivedTicker();
</script>
{% endblock %}
